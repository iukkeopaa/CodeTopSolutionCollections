1.如果每次默认从链表尾部添加元素，那么显然越靠近尾部的元素就越是最近使用的。越靠近头部的元素就是越久未使用的。

2.对于某一个 key ，可以通过哈希表快速定位到链表中的节点，从而取得对应的 value。

3.链表显示是支持在任意位置快速插入和删除的，修改指针就行。但是单链表无非按照索引快速访问某一个位置的元素，都是需要遍历链表的，所以这里借助哈希表，可以通过 key，快速的映射到任意一个链表节点，然后进行插入和删除。

#### 一、为什么这里要使用双向链表，而不是单向链表？

我们在找到了节点，需要删除节点的时候，如果使用单向链表的话，后驱节点的指针是直接能拿到的，但是这里要求时间复杂度是O(1)，要能够直接获取到前驱节点的指针，那么只能使用双向链表。

####  二、哈希表里面已经保存了 key ，那么链表中为什么还要存储 key 和 value 呢，只存入 value 不就行了？

当我们在删除节点的时候，除了需要删除链表中的节点，还需要删除hash表中的节点，删除哈希表需要知道key，那么这个key从哪里来？那只能从节点里来，所以在节点里key和value都需要存